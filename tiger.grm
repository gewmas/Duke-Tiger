structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | UMINUS
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  decs of A.dec list | dec of A.dec
          | tydec of A.dec | ty of A.ty | tyfields of A.field list 
          | vardec of A.dec
          | fundec of A.dec
          | exps of A.exp list | letExps of (A.exp * A.pos) list | exp of A.exp | startExp of A.exp | recordExp of A.exp | evalExp of A.exp
          | lvalue of A.var
          | oper of A.oper | arithmeticOper of A.oper | comparisonOper of A.oper  
          | recordList of (A.symbol * A.exp * A.pos) list
          | matchedIfThenElseExp of A.exp | unmatchedIfThenElseExp of A.exp
          | notIfThenElseExp of A.exp | ifThenElseExp of A.exp

%start startExp

%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left OR AND
%left UMINUS

%pos int
%verbose
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
  DO OF NIL

%prefer THEN ELSE LPAREN


%%

decs : dec                                                          (dec::nil)
    | dec decs                                                      (dec::decs)
dec : tydec                                                         (tydec)
    | vardec                                                        (vardec)
    | fundec                                                        (fundec)

tydec : TYPE ID EQ ty                                          (A.TypeDec([{name=Symbol.symbol(ID), ty=ty, pos=TYPEleft}]))

ty : ID                                                        (A.NameTy(Symbol.symbol(ID), IDleft))
    | LBRACE tyfields RBRACE                                        (A.RecordTy(tyfields))
    | ARRAY OF ID                                              (A.ArrayTy(Symbol.symbol(ID), ARRAYleft))

tyfields :                                                          ([])
          | ID COLON ID                                        ([{name=Symbol.symbol(ID1), escape=ref false, typ=Symbol.symbol(ID2), pos=ID1left}])
          | ID COLON ID  COMMA tyfields                        ({name=Symbol.symbol(ID1), escape=ref false, typ=Symbol.symbol(ID2), pos=ID1left}::tyfields)
  

vardec : VAR ID ASSIGN exp                                          (A.VarDec({name=Symbol.symbol(ID), escape=ref false, typ=NONE, init=exp, pos=VARleft}))
      | VAR ID COLON ID ASSIGN exp                             (A.VarDec({name=Symbol.symbol(ID1), escape=ref false, typ=SOME((Symbol.symbol(ID2), ID2left)), init=exp, pos=VARleft}))
      | VAR ID COLON ID ASSIGN ID LBRACK evalExp RBRACK OF evalExp
                                                                    (A.VarDec({name=Symbol.symbol(ID1), escape=ref false, typ=SOME((Symbol.symbol(ID2), ID2left)), init=A.ArrayExp({typ=Symbol.symbol(ID3), size=evalExp1, init=evalExp2, pos=ID3left}), pos=VARleft}) )

fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp                  (A.FunctionDec([{name=Symbol.symbol(ID), params=tyfields, result=NONE, body=exp, pos=FUNCTIONleft}]))
      | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp     (A.FunctionDec([{name=Symbol.symbol(ID1), params=tyfields, result=SOME((Symbol.symbol(ID2), ID2left)), body=exp, pos=FUNCTIONleft}]))

exps : exp                                                          (exp::nil)
    | exp SEMICOLON exps                                            (exp::exps)
    | exp COMMA exps                                                (exp::exps)

letExps : exp                                                       ((exp, expleft)::nil)
        | exp SEMICOLON letExps                                     ((exp, expleft)::letExps)

                                  
oper : arithmeticOper                                               (arithmeticOper)
      | comparisonOper                                              (comparisonOper)

arithmeticOper : TIMES                                              (A.TimesOp)         
              | DIVIDE                                              (A.DivideOp)
              | PLUS                                                (A.PlusOp)
              | MINUS                                               (A.MinusOp)
                                    
comparisonOper : EQ                                                 (A.EqOp)
              | NEQ                                                 (A.NeqOp)
              | GT                                                  (A.GtOp)
              | LT                                                  (A.LtOp)
              | GE                                                  (A.GeOp)
              | LE                                                  (A.LeOp)
                                            
                      
lvalue : ID                                                         (A.SimpleVar(Symbol.symbol(ID) , IDleft))
        | lvalue DOT ID                                             (A.FieldVar(lvalue, Symbol.symbol("a") , lvalueleft))
        | lvalue LBRACK evalExp RBRACK                                  (A.SubscriptVar(lvalue, evalExp , lvalueleft))
                      
evalExp : exp oper exp                                              (A.OpExp({left=exp1, oper=oper, right=exp2, pos=exp1left}))
        | exp AND exp                                               (A.IfExp({test=exp1, then'= exp2, else'= SOME(A.IntExp(0)), pos=exp1left}))
        | exp OR exp                                                (A.IfExp({test=exp1, then'= A.IntExp(1), else'= SOME(exp2), pos=exp1left}))

startExp : exp                                                      (exp)

exp : 
    ifThenElseExp                                                   (ifThenElseExp)


notIfThenElseExp : LET decs IN letExps END                          (A.LetExp({decs=decs, body=A.SeqExp(letExps), pos=LETleft}))
    | lvalue                                                        (A.VarExp(lvalue))
    | NIL                                                           (A.NilExp)
    | LPAREN exp SEMICOLON letExps RPAREN                           (A.SeqExp((exp, LPARENleft)::letExps))
    | INT                                                           (A.IntExp(INT))
    | STRING                                                        (A.StringExp(STRING, STRINGleft))
    | ID LPAREN exps RPAREN                                         (A.CallExp({func=Symbol.symbol(ID), args=exps, pos=IDleft}))
    | MINUS exp %prec UMINUS                                        (A.OpExp({left=A.IntExp(0), oper=A.MinusOp, right=exp, pos=MINUSleft}))
    | recordExp                                                     (recordExp)
    | lvalue ASSIGN evalExp                                         (A.AssignExp({var=lvalue, exp=evalExp, pos=lvalueleft}))
    | WHILE exp DO exp                                              (A.WhileExp({test=exp1, body=exp2, pos=WHILEleft}))
    | FOR ID ASSIGN evalExp TO evalExp DO exp                       (A.ForExp({var=Symbol.symbol(ID), escape=ref false, lo=evalExp1, hi=evalExp2, body=exp, pos=FORleft}))
    | BREAK                                                         (A.BreakExp(BREAKleft))
    | LPAREN exp RPAREN                                             (exp)

ifThenElseExp : matchedIfThenElseExp                                (matchedIfThenElseExp)
              | unmatchedIfThenElseExp                              (unmatchedIfThenElseExp)


matchedIfThenElseExp : IF evalExp THEN matchedIfThenElseExp ELSE matchedIfThenElseExp 
                                                                    (A.IfExp({test=evalExp, then'=matchedIfThenElseExp1, else'=SOME(matchedIfThenElseExp2), pos= IFleft}))
                      | notIfThenElseExp                            (notIfThenElseExp)
unmatchedIfThenElseExp : IF evalExp THEN exp                        (A.IfExp({test=evalExp, then'=exp, else'=NONE, pos= IFleft}))
                        | IF evalExp THEN matchedIfThenElseExp ELSE unmatchedIfThenElseExp 
                                                                    (A.IfExp({test=evalExp, then'=matchedIfThenElseExp, else'=SOME(unmatchedIfThenElseExp), pos= IFleft}))                      
                      
recordExp : ID LBRACE recordList RBRACE                        (A.RecordExp({fields=recordList, typ=Symbol.symbol(ID), pos=IDleft}))


recordList : ID EQ exp                                              ([(Symbol.symbol(ID), exp, IDleft)])
            | ID EQ exp COMMA recordList                            ((Symbol.symbol(ID), exp, IDleft)::recordList)
