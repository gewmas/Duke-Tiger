structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | UMINUS
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  decs of A.dec list | dec of A.dec
          | tydec of A.dec | ty of A.ty | tyfields of A.field list | type_id of A.symbol
          | vardec of A.dec
          | fundec of A.dec
          | exps of A.exp list | exp of A.exp | startExp of A.exp | recordExp of A.exp | arrayExp of A.exp | evalExp of A.exp
          | lvalue of A.var
          | oper of A.oper | arithmeticOper of A.oper | comparisonOper of A.oper | booleanOper of A.oper 
          | recordList of (A.symbol * A.exp * A.pos) list
          | matchedIfThenElseExp of A.exp | unmatchedIfThenElseExp of A.exp
          | notIfThenElseExp of A.exp | ifThenElseExp of A.exp

%start startExp

%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left OR AND
%left UMINUS

%pos int
%verbose
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
  DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

decs : dec                                                          (dec::nil)
    | dec decs                                                      (dec::decs)
dec : tydec                                                         (tydec)
    | vardec                                                        (vardec)
    | fundec                                                        (fundec)

tydec : TYPE type_id EQ ty                                          (A.TypeDec([{name=type_id, ty=ty, pos=tyleft}]))

ty : type_id                                                        (A.NameTy(type_id, type_idleft))
    | LBRACE tyfields RBRACE                                        (A.RecordTy(tyfields))
    | ARRAY OF type_id                                              (A.ArrayTy(type_id, type_idleft))

tyfields :                                                          ([])
          | ID COLON type_id                                        ([{name=Symbol.symbol(ID), escape=ref false, typ=type_id, pos=type_idleft}])
          | ID COLON type_id  COMMA tyfields                        ({name=Symbol.symbol(ID), escape=ref false, typ=type_id, pos=tyfieldsleft}::tyfields)

type_id : STRING                                                    (Symbol.symbol(STRING))
  

vardec : VAR ID ASSIGN exp                                          (A.VarDec({name=Symbol.symbol(ID), escape=ref false, typ=NONE, init=exp, pos=expleft}))
      | VAR ID COLON type_id ASSIGN exp                             (A.VarDec({name=Symbol.symbol(ID), escape=ref false, typ=SOME((type_id, type_idleft)), init=exp, pos=expleft}))


fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp                  (A.FunctionDec([{name=Symbol.symbol(ID), params=tyfields, result=NONE, body=exp, pos=expleft}]))
      | FUNCTION ID LPAREN tyfields RPAREN COLON type_id EQ exp     (A.FunctionDec([{name=Symbol.symbol(ID), params=tyfields, result=SOME((type_id, type_idleft)), body=exp, pos=expleft}]))




exps : exp                                                          (exp::nil)
    | exp SEMICOLON exps                                            (exp::exps)
    | exp COMMA exps                                                (exp::exps)
                                        
oper : arithmeticOper                                               (arithmeticOper)
      | comparisonOper                                              (comparisonOper)
      | booleanOper                                                 (booleanOper)

arithmeticOper : TIMES                                              (A.TimesOp)         
              | DIVIDE                                              (A.DivideOp)
              | PLUS                                                (A.PlusOp)
              | MINUS                                               (A.MinusOp)
                                    
comparisonOper : EQ                                                 (A.EqOp)
              | NEQ                                                 (A.NeqOp)
              | GT                                                  (A.GtOp)
              | LT                                                  (A.LtOp)
              | GE                                                  (A.GeOp)
              | LE                                                  (A.LeOp)
                                              
booleanOper : AND                                                   (A.GtOp)
              | OR                                                  (A.GtOp)
                      
lvalue : ID                                                         (A.SimpleVar(Symbol.symbol(ID) , 10))
        | lvalue DOT ID                                             (A.FieldVar(lvalue, Symbol.symbol("a") , 10))
        | lvalue LBRACK exp RBRACK                                  (A.SubscriptVar(lvalue, exp , 10))
                      
evalExp : exp oper exp                                              (A.OpExp({left=exp1, oper=oper, right=exp2, pos=10}))

startExp : exp (exp)

exp : 
    ifThenElseExp (ifThenElseExp)

notIfThenElseExp : LET decs IN exp END                              (A.LetExp({decs=decs, body=exp, pos=10}))
    | lvalue                                                        (A.VarExp(lvalue))
    | NIL                                                           (A.NilExp)
    | LPAREN exp SEMICOLON exps RPAREN                              (A.SeqExp([(A.NilExp, 10)]))
    | INT                                                           (A.IntExp(INT))
    | STRING                                                        (A.StringExp(STRING, 10))
    | ID LPAREN RPAREN                                              (A.CallExp({func=Symbol.symbol("a"), args=[], pos=10}))
    | ID LPAREN exps RPAREN                                         (A.CallExp({func=Symbol.symbol("a"), args=exps, pos=10}))
    | MINUS exp %prec UMINUS                                        (A.OpExp({left=A.IntExp(0), oper=A.MinusOp, right=exp, pos=10}))
    | recordExp                                                     (recordExp)
    | arrayExp                                                      (arrayExp)
    | lvalue ASSIGN evalExp                                         (A.AssignExp({var=lvalue, exp=evalExp, pos=10}))
    | WHILE exp DO exp                                              (A.WhileExp({test=exp1, body=exp2, pos=exp2right}))
    | FOR exp TO exp DO exp                                         (A.ForExp({var=Symbol.symbol("a"), escape=ref true, lo=exp1, hi=exp2, body=exp3, pos=10}))
    | BREAK                                                         (A.BreakExp(10))
    | LPAREN exp RPAREN                                             (exp)

ifThenElseExp : matchedIfThenElseExp                                (matchedIfThenElseExp)
              | unmatchedIfThenElseExp                              (unmatchedIfThenElseExp)


matchedIfThenElseExp : IF evalExp THEN matchedIfThenElseExp ELSE matchedIfThenElseExp 
                                                                    (A.NilExp)
                      | notIfThenElseExp                            (notIfThenElseExp)
unmatchedIfThenElseExp : IF evalExp THEN exp (A.NilExp)
                        | IF evalExp THEN matchedIfThenElseExp ELSE unmatchedIfThenElseExp (A.NilExp)                      
                      
recordExp : type_id LBRACE recordList RBRACE                        (A.RecordExp({fields=recordList, typ=Symbol.symbol("a"), pos=10}))
arrayExp : type_id LBRACK exp RBRACK OF exp                         (A.ArrayExp({typ=Symbol.symbol("a"), size=A.NilExp, init=A.NilExp, pos=10}))

recordList : ID EQ exp                                              ([(Symbol.symbol("a"), A.NilExp, 10)])
            | ID EQ exp COMMA recordList                            ([(Symbol.symbol("a"), A.NilExp, 10)])


